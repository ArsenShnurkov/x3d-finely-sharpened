<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "http://www.web3d.org/specifications/x3d-3.3.dtd">
<X3D profile='Interchange' version='3.3' xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.3.xsd'>
  <head>
    <meta content='Sphere.x3d' name='title'/>
    <meta content='Sphere geometric primitive node with tesselation shader for X3D spec consideration' name='description'/>
    <meta content='Gerallt Franke' name='creator'/>
    <meta content='10 June 2016' name='created'/>
  </head>
  <Scene>
    <Shape>
		<Sphere />
		<Appearance>
			<Material diffuseColor='0 1.0 1.0' />
			<ImageTexture url='"spectrum.jpg"'/>
			
			<ComposedShader language='GLSL'>
				<field accessType='inputOnly' name='TessLevelInner' type='SFFloat' value="3"/>
				<field accessType='inputOnly' name='TessLevelOuter' type='SFFloat' value="2" />
				
				
				<ShaderPart type='VERTEX' url='data:text/plain
#version 420 core &#13;
layout(location = 0) in vec3 position;&#13;
layout(location = 1) in vec3 normal;&#13;
layout(location = 2) in vec4 color;&#13;
layout(location = 3) in vec2 texcoord;&#13;
uniform mat4 modelview;&#13;
uniform mat4 projection;&#13;
uniform float camscale;&#13;
uniform vec3 size;&#13;
uniform vec3 scale;&#13;
uniform vec3 X3DScale;&#13;
uniform int coloringEnabled;&#13;
uniform int texturingEnabled;&#13;
varying vec3 lightVec;&#13;
varying vec3 eyeVec;&#13;
varying vec3 normalVec;&#13;
out vec4 vColor;&#13;
out lowp vec2 uv;&#13;
out vec3 vPosition;&#13;
void main()&#13;
{&#13;
    mat4 model = projection * modelview;&#13;
    vPosition = X3DScale * camscale * scale * size * position;&#13;
	gl_Position = model * vec4(vPosition, 1.0);&#13;
    vColor = color;&#13;
	normalVec = normalize(normal); &#13;
	vec4 eyePos = gl_ModelViewMatrixInverse * vec4(0., 0., 0., 1.); &#13;
	eyeVec = normalize(eyePos.xyz - position.xyz);&#13;
	vec4 lightPos = modelview * vec4(1.0, 0.0, 0.0, 1.0);&#13;
	lightVec = normalize(lightPos.xyz - position.xyz);&#13;
    uv = texcoord;&#13;
}&#13;' />
					  
					   
				<ShaderPart type='FRAGMENT' url='data:text/plain
#version 420 core&amp;#13;
varying vec3 lightVec;&#13;
varying vec3 eyeVec;&#13;
varying vec3 normalVec;&#13;
in vec3 gFacetNormal;&#13;
in vec3 gTriDistance;&#13;
in vec3 gPatchDistance;&#13;
in float gPrimitive;&#13;
in vec2 gFacetTexCoord;&#13;
in vec2 uv;&#13;
in vec4 vColor;&#13;
out vec4 FragColor;&#13;
uniform sampler2D _MainTex;&#13;
uniform vec3 specular = vec3(.7, .7, .7);&#13;
uniform float ambient = 0.2;&#13;
uniform vec3 LightPosition;&#13;
uniform vec3 DiffuseMaterial;&#13;
uniform vec3 AmbientMaterial;&#13;
uniform int coloringEnabled;&#13;
uniform int texturingEnabled;&#13;
float amplify(float d, float scale, float offset)&#13;
{&#13;
    d = scale * d + offset;&#13;
    d = clamp(d, 0, 1);&#13;
    d = 1 - exp2(-2*d*d);&#13;
    return d;&#13;
}&#13;
void main()&#13;
{&#13;
    vec4 texture_color;&#13;
    if(texturingEnabled == 1)&#13;
    {&#13;
        if(length(uv) == 0)&#13;
        {&#13;
            texture_color = texture2D(_MainTex, gFacetTexCoord);&#13;
        }&#13;
        else&#13;
        {&#13;
            texture_color = texture2D(_MainTex, uv);&#13;
        }&#13;
    }&#13;
    vec3 N = normalize(gFacetNormal);&#13;
    vec3 L = LightPosition;&#13;
    float df = abs(dot(N, L));&#13;
    vec3 color = AmbientMaterial + df * DiffuseMaterial;&#13;
    float d1 = min(min(gTriDistance.x, gTriDistance.y), gTriDistance.z);&#13;
    float d2 = min(min(gPatchDistance.x, gPatchDistance.y), gPatchDistance.z);&#13;
    color = amplify(d1, 40, -0.5) * amplify(d2, 60, -0.5) * color;&#13;
    vec4 col_accum;&#13;
    col_accum = vec4(color, 1.0) / 2;&#13;
    if(texturingEnabled == 1 &amp;&amp; coloringEnabled == 1)&#13;
    {&#13;
        col_accum = texture_color;&#13;
        col_accum = col_accum + vColor / 2;&#13;
    }&#13;
    else if (coloringEnabled == 1)&#13;
    {&#13;
        col_accum = vColor;&#13;
    }&#13;
    else if (texturingEnabled == 1)&#13;
    {&#13;
        col_accum = col_accum + texture_color / 2;&#13;
    }&#13;
    else&#13;
    {&#13;
        col_accum = vec4(0.0, 0, 0, 1.0);&#13;
    }&#13;
    FragColor = col_accum;&#13;
}&#13;' />
			</ComposedShader>
		</Appearance>
    </Shape>
  </Scene>
</X3D>